From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jake Potrebic <jake.m.potrebic@gmail.com>
Date: Tue, 18 Jul 2023 17:49:38 -0700
Subject: [PATCH] Add Lifecycle Event system

This event system is separate from Bukkit's event system and is
meant for managing resources across reloads and from points in the
PluginBootstrap.

diff --git a/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrapContextImpl.java b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrapContextImpl.java
index 30b50e6294c6eaade5e17cfaf34600d122e6251c..0d87642efcf446f96f6a5e932bd03d516e31f7a5 100644
--- a/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrapContextImpl.java
+++ b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrapContextImpl.java
@@ -1,6 +1,8 @@
 package io.papermc.paper.plugin.bootstrap;
 
 import io.papermc.paper.plugin.configuration.PluginMeta;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventManager;
+import io.papermc.paper.plugin.lifecycle.event.PaperLifecycleEventManager;
 import io.papermc.paper.plugin.provider.PluginProvider;
 import java.nio.file.Path;
 import net.kyori.adventure.text.logger.slf4j.ComponentLogger;
@@ -12,6 +14,7 @@ public final class PluginBootstrapContextImpl implements BootstrapContext {
     private final Path dataFolder;
     private final ComponentLogger logger;
     private final Path pluginSource;
+    private final PaperLifecycleEventManager<BootstrapContext> lifecycleEventManager = new PaperLifecycleEventManager<>(this); // Paper - lifecycle events
 
     public PluginBootstrapContextImpl(PluginMeta config, Path dataFolder, ComponentLogger logger, Path pluginSource) {
         this.config = config;
@@ -45,4 +48,20 @@ public final class PluginBootstrapContextImpl implements BootstrapContext {
     public @NotNull Path getPluginSource() {
         return this.pluginSource;
     }
+
+    // Paper start - lifecycle event system
+    @Override
+    public @NotNull PluginMeta getPluginMeta() {
+        return this.config;
+    }
+
+    @Override
+    public LifecycleEventManager<BootstrapContext> getLifecycleManager() {
+        return this.lifecycleEventManager;
+    }
+
+    public void lockLifecycleEventRegistration() {
+        this.lifecycleEventManager.allowRegistration = false;
+    }
+    // Paper end
 }
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventRunner.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventRunner.java
new file mode 100644
index 0000000000000000000000000000000000000000..864036e430f14e8b2ab1370ae37ad984c21b0a61
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventRunner.java
@@ -0,0 +1,53 @@
+package io.papermc.paper.plugin.lifecycle.event;
+
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.plugin.lifecycle.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.registrar.RegistrarEvent;
+import io.papermc.paper.plugin.lifecycle.event.registrar.ReloadableRegistrarEventImpl;
+import io.papermc.paper.plugin.lifecycle.event.registrar.ResourceRegistrar;
+import io.papermc.paper.plugin.lifecycle.event.registrar.StaticRegistrarEventImpl;
+import io.papermc.paper.plugin.lifecycle.event.types.AbstractLifecycleEventType;
+import org.bukkit.plugin.Plugin;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.slf4j.Logger;
+
+@DefaultQualifier(NonNull.class)
+public class LifecycleEventRunner {
+    public static final LifecycleEventRunner INSTANCE = new LifecycleEventRunner();
+
+    private static final Logger LOGGER = LogUtils.getClassLogger();
+
+    public <O extends LifecycleEventOwner, E extends LifecycleEvent> void callEvent(final LifecycleEventType<O, E> eventType, final E event) {
+        final AbstractLifecycleEventType<O, E> lifecycleEventType = (AbstractLifecycleEventType<O, E>) eventType;
+        lifecycleEventType.forEachHandler(registeredHandler -> {
+            try {
+                registeredHandler.lifecycleEventHandler().run(event);
+            } catch (Throwable ex) {
+                LOGGER.error("Could not run '{}' lifecycle event handler from {}", lifecycleEventType.name(), registeredHandler.owner().getPluginMeta().getDisplayName(), ex);
+            }
+        });
+    }
+
+    public void unregisterAllEventHandlersFor(final Plugin plugin) {
+        for (final LifecycleEventType<?, ?> lifecycleEventType : LifecycleEventTypeProviderImpl.instance().eventTypes()) {
+            this.removeEventHandlersOwnedBy(lifecycleEventType, plugin);
+        }
+    }
+
+    private <O extends LifecycleEventOwner> void removeEventHandlersOwnedBy(final LifecycleEventType<O, ?> eventType, final Plugin possibleOwner) {
+        final AbstractLifecycleEventType<O, ?> lifecycleEventType = (AbstractLifecycleEventType<O, ?>) eventType;
+        lifecycleEventType.removeMatching(registeredHandler -> registeredHandler.owner().getPluginMeta().getName().equals(possibleOwner.getPluginMeta().getName()));
+    }
+
+    public <O extends LifecycleEventOwner, R extends ResourceRegistrar> void callStaticRegistrarEvent(final LifecycleEventType<O, RegistrarEvent<R>> lifecycleEventType, final R registrar) {
+        this.callEvent(lifecycleEventType, new StaticRegistrarEventImpl<>(registrar));
+    }
+
+    public <O extends LifecycleEventOwner, R extends ResourceRegistrar> void callReloadableRegistrarEvent(final LifecycleEventType<O, RegistrarEvent.Reloadable<R>> lifecycleEventType, final R registrar, final RegistrarEvent.Reloadable.Cause cause) {
+        this.callEvent(lifecycleEventType, new ReloadableRegistrarEventImpl<>(registrar, cause));
+    }
+
+    private LifecycleEventRunner() {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventTypeProviderImpl.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventTypeProviderImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..39b96f664eb40829c5e2e832d2993fc54fd77d89
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/LifecycleEventTypeProviderImpl.java
@@ -0,0 +1,45 @@
+package io.papermc.paper.plugin.lifecycle.event;
+
+import io.papermc.paper.plugin.lifecycle.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.types.PrioritizedLifecycleEventType;
+import io.papermc.paper.plugin.lifecycle.event.types.SimpleLifecycleEventType;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import org.bukkit.plugin.Plugin;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public final class LifecycleEventTypeProviderImpl extends LifecycleEventTypeProvider {
+
+    private final List<LifecycleEventType<?, ?>> lifecycleEventTypes = new ArrayList<>();
+
+    public static LifecycleEventTypeProviderImpl instance() {
+        return (LifecycleEventTypeProviderImpl) LifecycleEventTypeProvider.PROVIDER;
+    }
+
+    public List<LifecycleEventType<?, ?>> eventTypes() {
+        return Collections.unmodifiableList(this.lifecycleEventTypes);
+    }
+
+    @Override
+    public <O extends LifecycleEventOwner, E extends LifecycleEvent> LifecycleEventType<O, E> simple(final String name, final Class<? extends O> ownerType) {
+        return this.add(new SimpleLifecycleEventType<>(name, ownerType));
+    }
+
+    @Override
+    public <O extends LifecycleEventOwner, E extends LifecycleEvent> LifecycleEventType.Prioritized<O, E> prioritized(final String name, final Class<? extends O> ownerType) {
+        return this.add(new PrioritizedLifecycleEventType<>(name, ownerType));
+    }
+
+    private <O extends LifecycleEventOwner, E extends LifecycleEvent, ET extends LifecycleEventType<O, E>> ET add(final ET eventType) {
+        this.lifecycleEventTypes.add(eventType);
+        return eventType;
+    }
+
+    @Override
+    public LifecycleEventManager<Plugin> createPluginLifecycleManager(final Plugin plugin) {
+        return new PaperLifecycleEventManager<>(plugin);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/PaperLifecycleEventManager.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/PaperLifecycleEventManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..60d6102aaf3ce9476529078ca0d65e4b6a5c7354
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/PaperLifecycleEventManager.java
@@ -0,0 +1,40 @@
+package io.papermc.paper.plugin.lifecycle.event;
+
+import com.google.common.base.Preconditions;
+import io.papermc.paper.plugin.lifecycle.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.types.AbstractLifecycleEventType;
+import io.papermc.paper.plugin.lifecycle.event.types.PrioritizedLifecycleEventType;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public final class PaperLifecycleEventManager<O extends LifecycleEventOwner> implements LifecycleEventManager<O> {
+
+    private final O owner;
+    public boolean allowRegistration = true;
+
+    public PaperLifecycleEventManager(final O owner) {
+        this.owner = owner;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <E extends LifecycleEvent, T extends LifecycleEventType<? super O, E>> void registerEventHandler(final T eventType, final LifecycleEventHandler<? super E> eventHandler) {
+        Preconditions.checkState(this.allowRegistration, "Cannot register lifecycle event handlers");
+        ((AbstractLifecycleEventType<? super O, E>) eventType).register(this.owner, eventHandler);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <E extends LifecycleEvent, T extends LifecycleEventType<? super O, E>> void registerMonitorEventHandler(final T eventType, final LifecycleEventHandler<? super E> eventHandler) {
+        Preconditions.checkState(this.allowRegistration, "Cannot register lifecycle event handlers");
+        ((AbstractLifecycleEventType<? super O, E>) eventType).registerAsMonitor(this.owner, eventHandler);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <E extends LifecycleEvent, T extends LifecycleEventType.Prioritized<? super O, E>> void registerPrioritizedEventHandler(final T eventType, final LifecycleEventHandler<? super E> eventHandler, final int priority) {
+        Preconditions.checkState(this.allowRegistration, "Cannot register lifecycle event handlers");
+        ((PrioritizedLifecycleEventType<? super O, E>) eventType).registerWithPriority(this.owner, eventHandler, priority);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/ReloadableRegistrarEventImpl.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/ReloadableRegistrarEventImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..1a1ff329a0743ab43206348d8443e3dd1a5bbd1d
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/ReloadableRegistrarEventImpl.java
@@ -0,0 +1,8 @@
+package io.papermc.paper.plugin.lifecycle.event.registrar;
+
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public record ReloadableRegistrarEventImpl<R extends ResourceRegistrar>(R registrar, Cause cause) implements RegistrarEvent.Reloadable<R> {
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/StaticRegistrarEventImpl.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/StaticRegistrarEventImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..4c7a876b71847e67795f98cfb5ad1729cfb41bb4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/registrar/StaticRegistrarEventImpl.java
@@ -0,0 +1,8 @@
+package io.papermc.paper.plugin.lifecycle.event.registrar;
+
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public record StaticRegistrarEventImpl<R extends ResourceRegistrar>(R registrar) implements RegistrarEvent<R> {
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/AbstractLifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/AbstractLifecycleEventType.java
new file mode 100644
index 0000000000000000000000000000000000000000..3c1e8a544e194b0e50aabf87b9138f8800dfb6e1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/AbstractLifecycleEventType.java
@@ -0,0 +1,44 @@
+package io.papermc.paper.plugin.lifecycle.event.types;
+
+import io.papermc.paper.plugin.lifecycle.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventType;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public abstract class AbstractLifecycleEventType<O extends LifecycleEventOwner, E extends LifecycleEvent> implements LifecycleEventType<O, E> {
+
+    private final String name;
+    private final Class<? extends O> ownerType;
+
+    protected AbstractLifecycleEventType(final String name, final Class<? extends O> ownerType) {
+        this.name = name;
+        this.ownerType = ownerType;
+    }
+
+    @Override
+    public String name() {
+        return this.name;
+    }
+
+    protected final void verifyOwner(final O owner) {
+        if (!this.ownerType.isInstance(owner)) {
+            throw new IllegalArgumentException("You cannot register the lifecycle event '" + this.name + "' on " + owner);
+        }
+    }
+
+    public abstract void forEachHandler(Consumer<? super RegisteredHandler<O, E>> consumer);
+
+    public abstract void removeMatching(Predicate<? super RegisteredHandler<O, E>> predicate);
+
+    public abstract void register(final O owner, final LifecycleEventHandler<? super E> lifecycleEventHandler);
+
+    public abstract void registerAsMonitor(final O owner, final LifecycleEventHandler<? super E> lifecycleEventHandler);
+
+    public record RegisteredHandler<O, E extends LifecycleEvent>(O owner, LifecycleEventHandler<? super E> lifecycleEventHandler) {
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizedLifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizedLifecycleEventType.java
new file mode 100644
index 0000000000000000000000000000000000000000..2e5ed51ee1ea9fbc1ef6c282764f9d5b268835ea
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/PrioritizedLifecycleEventType.java
@@ -0,0 +1,70 @@
+package io.papermc.paper.plugin.lifecycle.event.types;
+
+import io.papermc.paper.plugin.lifecycle.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventType;
+import java.util.Comparator;
+import java.util.NavigableSet;
+import java.util.OptionalInt;
+import java.util.TreeSet;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public class PrioritizedLifecycleEventType<O extends LifecycleEventOwner, E extends LifecycleEvent> extends AbstractLifecycleEventType<O, E> implements LifecycleEventType.Prioritized<O, E> {
+
+    private static final OptionalInt MONITOR_PRIORITY = OptionalInt.empty();
+    private static final OptionalInt DEFAULT_PRIORITY = OptionalInt.of(0);
+
+    private final NavigableSet<PrioritizedHandler<O, E>> handlers = new TreeSet<>(Comparator.comparing(PrioritizedHandler::priority, (o1, o2) -> {
+        if (o1.equals(o2)) {
+            return 0;
+        } else if (o1.isEmpty()) {
+            return 1;
+        } else if (o2.isEmpty()) {
+            return -1;
+        } else {
+            return Integer.compare(o1.getAsInt(), o2.getAsInt());
+        }
+    }));
+
+    public PrioritizedLifecycleEventType(final String name, final Class<? extends O> ownerType) {
+        super(name, ownerType);
+    }
+
+    @Override
+    public void register(final O owner, final LifecycleEventHandler<? super E> lifecycleEventHandler) {
+        this.registerWithPriority(owner, lifecycleEventHandler, DEFAULT_PRIORITY);
+    }
+
+    @Override
+    public void registerAsMonitor(final O owner, final LifecycleEventHandler<? super E> lifecycleEventHandler) {
+        this.registerWithPriority(owner, lifecycleEventHandler, MONITOR_PRIORITY);
+    }
+
+    public void registerWithPriority(final O owner, final LifecycleEventHandler<? super E> lifecycleEventHandler, final int priority) {
+        this.registerWithPriority(owner, lifecycleEventHandler, OptionalInt.of(priority));
+    }
+
+    public void registerWithPriority(final O owner, final LifecycleEventHandler<? super E> lifecycleEventHandler, final OptionalInt priority) {
+        this.verifyOwner(owner);
+        this.handlers.add(new PrioritizedHandler<>(new RegisteredHandler<>(owner, lifecycleEventHandler), priority));
+    }
+
+    @Override
+    public void forEachHandler(final Consumer<? super RegisteredHandler<O, E>> consumer) {
+        for (final PrioritizedHandler<O, E> handler : this.handlers) {
+            consumer.accept(handler.handler());
+        }
+    }
+
+    @Override
+    public void removeMatching(final Predicate<? super RegisteredHandler<O, E>> predicate) {
+        this.handlers.removeIf(prioHandler -> predicate.test(prioHandler.handler()));
+    }
+
+    private record PrioritizedHandler<O extends LifecycleEventOwner, E extends LifecycleEvent>(RegisteredHandler<O, E> handler, OptionalInt priority) {}
+}
diff --git a/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/SimpleLifecycleEventType.java b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/SimpleLifecycleEventType.java
new file mode 100644
index 0000000000000000000000000000000000000000..d931a84d7c0ca6832244115c000de0130ec9bed6
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/lifecycle/event/types/SimpleLifecycleEventType.java
@@ -0,0 +1,47 @@
+package io.papermc.paper.plugin.lifecycle.event.types;
+
+import io.papermc.paper.plugin.lifecycle.LifecycleEvent;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventHandler;
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventOwner;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+@DefaultQualifier(NonNull.class)
+public class SimpleLifecycleEventType<O extends LifecycleEventOwner, E extends LifecycleEvent> extends AbstractLifecycleEventType<O, E> {
+
+    final List<RegisteredHandler<O, E>> handlers = new ArrayList<>();
+    int nonMonitorIdx = 0;
+
+    public SimpleLifecycleEventType(final String name, final Class<? extends O> ownerType) {
+        super(name, ownerType);
+    }
+
+    @Override
+    public void register(final O owner, final LifecycleEventHandler<? super E> lifecycleEventHandler) {
+        this.verifyOwner(owner);
+        this.handlers.add(this.nonMonitorIdx, new RegisteredHandler<>(owner, lifecycleEventHandler));
+        this.nonMonitorIdx++;
+    }
+
+    @Override
+    public void registerAsMonitor(final O owner, final LifecycleEventHandler<? super E> lifecycleEventHandler) {
+        this.verifyOwner(owner);
+        this.handlers.add(new RegisteredHandler<>(owner, lifecycleEventHandler));
+    }
+
+    @Override
+    public void forEachHandler(final Consumer<? super RegisteredHandler<O, E>> consumer) {
+        for (final RegisteredHandler<O, E> handler : this.handlers) {
+            consumer.accept(handler);
+        }
+    }
+
+    @Override
+    public void removeMatching(final Predicate<? super RegisteredHandler<O, E>> predicate) {
+        this.handlers.removeIf(predicate);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java
index 9c7552968b8c017c71a7a77557a66a03ed89f125..c7cf369f36a3fa7d48320d67191d74ce211f2001 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java
@@ -187,7 +187,9 @@ class PaperPluginInstanceManager {
 
             try {
                 jPlugin.setEnabled(true);
+                ((io.papermc.paper.plugin.lifecycle.event.PaperLifecycleEventManager<?>) (jPlugin.getLifecycleManager())).allowRegistration = false; // Paper - stop allowing lifecycle event registration
             } catch (Throwable ex) {
+                ((io.papermc.paper.plugin.lifecycle.event.PaperLifecycleEventManager<?>) (jPlugin.getLifecycleManager())).allowRegistration = false; // Paper - stop allowing lifecycle event registration
                 this.server.getLogger().log(Level.SEVERE, "Error occurred while enabling " + plugin.getPluginMeta().getDisplayName() + " (Is it up to date?)", ex);
                 // Paper start - Disable plugins that fail to load
                 this.server.getPluginManager().disablePlugin(jPlugin);
@@ -261,6 +263,15 @@ class PaperPluginInstanceManager {
                 + pluginName + " (Is it up to date?)", ex, plugin); // Paper
         }
 
+        // Paper start - lifecycle event system
+        try {
+            io.papermc.paper.plugin.lifecycle.event.LifecycleEventRunner.unregisterAllEventHandlersFor(plugin);
+        } catch (Throwable ex) {
+            this.handlePluginException("Error occurred (in the plugin loader) while unregistering lifecycle event handlers for "
+                + pluginName + " (Is it up to date?)", ex, plugin);
+        }
+        // Paper end
+
         try {
             this.server.getMessenger().unregisterIncomingPluginChannel(plugin);
             this.server.getMessenger().unregisterOutgoingPluginChannel(plugin);
diff --git a/src/main/java/io/papermc/paper/plugin/storage/BootstrapProviderStorage.java b/src/main/java/io/papermc/paper/plugin/storage/BootstrapProviderStorage.java
index 8ef13e4f00a61db0dab9ef63231d77adcfaba5ab..79ec67dd6dc71f83e23f722811369723c155195d 100644
--- a/src/main/java/io/papermc/paper/plugin/storage/BootstrapProviderStorage.java
+++ b/src/main/java/io/papermc/paper/plugin/storage/BootstrapProviderStorage.java
@@ -30,8 +30,9 @@ public class BootstrapProviderStorage extends SimpleProviderStorage<PluginBootst
             @Override
             public boolean load(PluginProvider<PluginBootstrap> provider, PluginBootstrap provided) {
                 try {
-                    BootstrapContext context = PluginBootstrapContextImpl.create(provider, PluginInitializerManager.instance().pluginDirectoryPath());
+                    PluginBootstrapContextImpl context = PluginBootstrapContextImpl.create(provider, PluginInitializerManager.instance().pluginDirectoryPath()); // Paper - lifecycle events
                     provided.bootstrap(context);
+                    context.lockLifecycleEventRegistration(); // Paper - lifecycle events
                     return true;
                 } catch (Throwable e) {
                     LOGGER.error("Failed to run bootstrapper for %s. This plugin will not be loaded.".formatted(provider.getSource()), e);
diff --git a/src/main/resources/META-INF/services/io.papermc.paper.plugin.lifecycle.event.LifecycleEventTypeProvider b/src/main/resources/META-INF/services/io.papermc.paper.plugin.lifecycle.event.LifecycleEventTypeProvider
new file mode 100644
index 0000000000000000000000000000000000000000..c647fd9cef4f82b6ef17a942c208cc37bf5e99c2
--- /dev/null
+++ b/src/main/resources/META-INF/services/io.papermc.paper.plugin.lifecycle.event.LifecycleEventTypeProvider
@@ -0,0 +1 @@
+io.papermc.paper.plugin.lifecycle.event.LifecycleEventTypeProviderImpl
